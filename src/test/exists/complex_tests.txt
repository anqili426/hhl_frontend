/*
// Functional inv
method functional(x: Int) returns (res: Int)
requires exists _s: State :: <_s> && get(_s, x) == 3
ensures exists _s: State :: <_s> && get(_s, res) == get(_s, x)
{
     let $s: State :: <$s> && get($s, x) == 3
     res := 0
     while (res < x)
     {hint2} invariant $n <= get($s, x) ==> exists _s: State :: <_s>
     && get(_s, res) <= get(_s, x) && get(_s, res) == $n && get(_s, x) == get($s, x)
     {
         res := res + 1
     }
     use hint2(3)
}

// Nested if-else
method lex_transitivity(x1: Int, x2: Int, y1: Int, y2: Int, i: Int) returns (res: Int)
requires exists _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 && get(_s1, x1) == get(_s3, x1) && get(_s1, x2) == get(_s3, x2) && get(_s2, y1) == get(_s3, y1) && get(_s2, y2) == get(_s3, y2) && get(_s1, y1) == get(_s2, x1) && get(_s1, y2) == get(_s2, x2)
ensures exists _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 && (get(_s1, res) == 1 && get(_s2, res) == 1 ==> get(_s3, res) == 1)
{
   if (x1 < y1) {
        res := 1
   } else {
    if (x1 == y1) {
        if (x2 <= y2) {
            res := 1
        } else {
            res := 0
        }
    } else {
        res := 0
    }
   }
}

// Loops in if-else
method loop_in_if_else(y: Int) returns (res: Int)
requires exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, y) == get(_s2, y) && get(_s1, y) >= 0
requires exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, y) == get(_s2, y) && get(_s1, y) < 0
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, y) >= 0 && get(_s1, res) == get(_s2, res)
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, y) < 0 && get(_s1, res) == get(_s2, res)
{
    let $s1: State :: <$s1> && get($s1, y) >= 0
    let $s2: State :: <$s2> && get($s2, y) < 0
    res := 0
        if (y >= 0) {
            while (res < y)
                {hint4} invariant $n <= get($s1, y) ==> exists _s: State :: <_s> && get(_s, res) <= get(_s, y) && get(_s, res) == $n && get(_s, y) == get($s1, y)
            {
                res := res + 1
            }
        } else {
            while (res < (-1) * y)
                {hint5} invariant $n <= -1 * get($s2, y) ==> exists _s: State :: <_s> && get(_s, res) <= -1 * get(_s, y) && get(_s, res) == $n && get(_s, y) == get($s2, y)
            {
                res := res + 1
            }
        }
    use hint4(get($s1, y))
    use hint5(-1 * get($s2, y))
} */
/*
// Nested loops
method nested_loops(x: Int) returns (res: Int)
requires exists _s: State :: <_s> && get(_s, x) > 0
ensures exists _s: State :: <_s> && get(_s, res) == get(_s, x)
{
    var i: Int
    i := 0
    res := 0

    let $s: State :: <$s> && get($s, x) > 0 && get($s, i) == 0 && get($s, res) == 0

    while (i < x)
    {hint6} invariant $n <= 1 ==> exists _s: State:: <_s>
                                    && get(_s, i) <= get(_s, x)
                                    && get(_s, x) == get($s, x)
                                    && get(_s, i) == get(_s, res)
                                    && get(_s, i) == $n * get(_s, x)
                                    && get($s, x) > 0
    {
        // $s1 doesn't necessarily exist
        let $s1: State :: <$s1> && get($s1, i) <= get($s1, x) && get($s1, x) == get($s, x)

        while (i < x)
        {hint7} invariant $n <= get($s1, x) - get($s1, i) ==> exists _s: State :: <_s> && get(_s, i) == $n + get($s1, i)
                                                                        && get(_s, i) <= get(_s, x)
                                                                        && get(_s, x) == get($s1, x)
        {
            i := i + 1
        }

        use hint7(get($s1, x) - get($s1, i))
        res := i
    }

    use hint6(1)
} */

// Two loops
method two_loops(x: Int) returns (res: Int)
requires exists _s: State :: <_s> && get(_s, x) == 3
ensures exists _s: State :: <_s> && get(_s, x) * get(_s, x) + get(_s, x) == get(_s, res)
{
    var i: Int
    i := 0
    res := 0

    let $s: State :: <$s> && get($s, x) == 3

    // Compute res = x * x
    while (i < x)
    {hint8} invariant $n <= get($s, x) ==> exists _s: State :: <_s>
                                                  && get(_s, i) == $n
                                                  && get(_s, x) == get($s, x)
                                                  && get(_s, res) == get(_s, i) * get(_s, x)
    {
        res := res + x
        i := i + 1
    }

    use hint8(get($s, x))

    i := 0

    // Compute res = res + x
    while (i < x)
    {hint9} invariant $n <= get($s, x) ==> exists _s: State :: <_s>
                                                  && get(_s, i) == $n
                                                  && get(_s, x) == get($s, x)
                                                  && get(_s, res) == get(_s, x) * get(_s, x) + get(_s, i)
    {
        res := res + 1
        i := i + 1
    }

    use hint9(get($s, x))
}

// If-else in loops
method if_else_in_loop(x: Int) returns (y: Int)
requires exists _s: State :: <_s> && get(_s, x) == 3
requires exists _s: State :: <_s> && get(_s, x) == 0
ensures exists _s: State :: <_s> && get(_s, y) == 3
ensures exists _s: State :: <_s> && get(_s, y) == -1
{
    y := -1
    var i: Int
    i := x

    let $s: State :: <$s> && get($s, x) == 3 && get($s, i) == get($s, x)
    let $s1: State :: <$s1> && get($s1, x) == 0 && get($s, i) == get($s, x) && get($s1, y) == -1

    while (i > 0)
    {hint10} invariant $n <= get($s, x) ==> exists _s: State :: <_s>
                                                    && get(_s, i) >= 0
                                                    && get(_s, x) - get(_s, i) == $n
                                                    && get(_s, x) == get($s, x)
                                                    && (get(_s, i) == 0 ==> get(_s, x) == get(_s, y))
    {hint11} invariant $n == 0 ==> exists _s: State :: <_s> && get(_s, x) == 0
                                                        && get(_s, i) == 0
                                                        && get(_s, y) == get($s1, y)
    {
       if (i == 1) {
         y := x
       } else {
         y := 2
       }
       i := i - 1
    }

    use hint10(get($s, x))
    use hint11(0)
}

// Relational inv
method relational(x: Int, n: Int, i: Int) returns (res: Int)
requires exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2
                                            && get(_s1, n) == get(_s2, n) && get(_s1, n) == 3
                                            && get(_s1, x) <= get(_s2, x) && get(_s1, x) == 4
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2
                                            && get(_s1, res) <= get(_s2, res)
{
    res := 0
    var ind: Int
    ind := 0

    let $s1: State :: <$s1> && get($s1, i) == 1 && get($s1, n) == 3
                            && get($s1, x) == 4 && get($s1, ind) == 0
                            && get($s1, res) == 0
    let $s2: State :: <$s2> && get($s2, i) == 2
                            && get($s2, x) >= get($s1, x)
                            && get($s2, n) == get($s1, n)
                            && get($s2, ind) == 0
                            && get($s2, res) == 0

    while (ind < n)
    {hint12} invariant $n <= get($s1, n) ==> exists _s1: State, _s2: State :: <_s1> && <_s2>
                                                        && get(_s1, i) == 1 && get(_s2, i) == 2
                                                        && get(_s2, x) >= get(_s1, x)
                                                        && get(_s1, n) == get(_s2, n)
                                                        && get(_s1, n) == get($s1, n)
                                                        && get(_s1, ind) == $n
                                                        && get(_s2, ind) == get(_s1, ind)
                                                        && get(_s1, res) <= get(_s2, res)
                                                        && get(_s1, ind) <= get(_s1, n)
    {
        res := 2 * x
        ind := ind + 1
    }

    use hint12(get($s1, n))
}

/*
// Alignment -- not supported for exists-HHL at the moment
method align(x: Int, n: Int, i: Int) returns (res: Int)
requires exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2
                                            && get(_s1, n) == get(_s2, n) && get(_s1, n) == 3
                                            && get(_s1, x) <= get(_s2, x) && get(_s1, x) == -1
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2
                                            && get(_s1, res) <= get(_s2, res)
{
    res := 0
    var ind: Int
    ind := 0

    let $s1: State :: <$s1> && get($s1, i) == 1 && get($s1, n) == 3
                            && get($s1, x) == -1 && get($s1, ind) == 0
                            && get($s1, res) == 0
    let $s2: State :: <$s2> && get($s2, i) == 2
                            && get($s2, x) >= get($s1, x)
                            && get($s2, n) == get($s1, n)
                            && get($s2, ind) == 0
                            && get($s2, res) == 0

    if (x > 0) {
        declare commonLoop {
            while (ind < n)
                {hint13} invariant $n <= get($s1, n) ==> exists _s1: State, _s2: State :: <_s1> && <_s2>
                                                                    && get(_s1, i) == 1 && get(_s2, i) == 2
                                                                    && get(_s2, x) >= get(_s1, x)
                                                                    && get(_s1, n) == get(_s2, n)
                                                                    && get(_s1, n) == get($s1, n)
                                                                    && get(_s1, ind) == $n
                                                                    && get(_s2, ind) == get(_s1, ind)
                                                                    && get(_s1, res) <= get(_s2, res)
                                                                    && get(_s1, ind) <= get(_s1, n)
                                                                    && get(_s1, x) == get($s1, x)
                {
                    res := 2 * x
                    ind := ind + 1
                }
        }
        // TODO: adding this line doesn't work any more...
        // res := res + 1
    } else {
        reuse commonLoop
    }

    use hint13(get($s1, n))
}
*/

method test1(x: Int, y: Int) returns (res: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2>  ==> get(_s1, x) == get(_s2, y) && get(_s1, y) == get(_s2, x)
ensures forall  _s1: State, _s2: State :: <_s1> && <_s2>  ==> get(_s1, res) == get(_s2, res)
{
    res := 0
    assume x * y > 0

    while (res < x * y)
    frame forall _s1: State, _s2: State :: <_s1> && <_s2>  ==> get(_s1, x) == get(_s2, y) && get(_s1, y) == get(_s2, x)
    invariant forall _s: State :: <_s> ==> get(_s, res) <= get(_s, x) * get(_s, y)
    {
        res := res + 1
    }
}

method test2(x: Int, y: Int) returns (res: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2>  ==> get(_s1, x) == get(_s2, y) && get(_s1, y) == get(_s2, x)
ensures forall _s: State :: <_s> ==> get(_s, res) == get(_s, x) * get(_s, x) + 2 * get(_s, x) * get(_s, y) + get(_s, y) * get(_s, y)
ensures forall  _s1: State, _s2: State :: <_s1> && <_s2>  ==> get(_s1, res) == get(_s2, res)
{
    res := x * x + 2 * x * y
    var i: Int
    i := 0

    while (i < y * y)
    frame forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, y) && get(_s1, y) == get(_s2, x)
    invariant forall _s: State :: <_s> ==> get(_s, res) == get(_s, x) * get(_s, x) + 2 * get(_s, x) * get(_s, y)
    invariant forall _s: State :: <_s> ==> get(_s, i) <= get(_s, y) * get(_s, y)
    {
            i := i + 1
    }

    res := res + i
}




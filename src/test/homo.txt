method test1(x: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, x) * get(_s2, x) == get(_s3, x)
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, res) * get(_s2, res) == get(_s3, res)
{
    res := x * x
}

method test2(x: Int, n: Int, i: Int) returns (res: Int)
requires forall _s: State :: <_s> ==> get(_s, x) > 0
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, x) * get(_s2, x) == get(_s3, x)
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, res) * get(_s2, res) == get(_s3, res)
{
    var num_add: Int
    num_add := 1
    res := x
    frame forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, x) * get(_s2, x) == get(_s3, x) {
        while (num_add < x)
            invariant forall _s: State :: <_s> ==> get(_s, res) == get(_s, x) * get(_s, num_add) && get(_s, num_add) <= get(_s, x)
        {
            res := res + x
            num_add := num_add + 1
        }
    }
}
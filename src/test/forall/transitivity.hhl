method test1(x: Int, y: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[x] == _s3[x] && _s1[y] == _s2[x] && _s2[y] == _s3[y]
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> (_s1[res] == 1 && _s2[res] == 1 ==> _s3[res] == 1)
{
    if (x > y) {
        res := 1
    } else {
        res := 0
    }
}

// This does not terminate
method test2(x: Int, y: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[x] == _s3[x] && _s1[y] == _s2[x] && _s2[y] == _s3[y]
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> (_s1[res] == 1 && _s2[res] == 1 ==> _s3[res] == 1)
{
    assume x >= y
    assume y > 0
    var remain_x: Int
    remain_x := x

    var ind: Int
    ind := 0

    // frame forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[x] == _s3[x] && _s1[y] == _s2[x] && _s2[y] == _s3[y] {
        while (ind < x / y)
        invariant forall <_s> :: _s[remain_x] == _s[x] - _s[ind] * _s[y] && _s[x] >= _s[y] && _s[y] > 0 && _s[ind] <= _s[x] / _s[y]
        {
            remain_x := remain_x - y
            ind := ind + 1
        }
    // }

    if (remain_x == 0) {
        res := 1
    } else {
        res := 0
    }
}


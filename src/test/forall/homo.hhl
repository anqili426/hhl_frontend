method test1(x: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[x] * _s2[x] == _s3[x]
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[res] * _s2[res] == _s3[res]
{
    res := x * x
}

method test2(x: Int, n: Int, i: Int) returns (res: Int)
requires forall <_s> :: _s[x] > 0
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[x] * _s2[x] == _s3[x]
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[res] * _s2[res] == _s3[res]
{
    var num_add: Int
    num_add := 1
    res := x
    //frame forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && _s1[i] == 1 && _s2[i] == 2 && _s3[i] == 3 ==> _s1[x] * _s2[x] == _s3[x] {
        while (num_add < x)
            invariant forall <_s> :: _s[res] == _s[x] * _s[num_add] && _s[num_add] <= _s[x]
        {
            res := res + x
            num_add := num_add + 1
        }
    //}
}
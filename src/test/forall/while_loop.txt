method test() returns (sum: Int)
    ensures forall _s: State :: <_s> ==> get(_s, sum) == 102
{

    var n: Int
    n := 0
    sum := 1

    while (n <= 100)
    invariant forall _s: State :: <_s> ==> (get(_s, sum) == get(_s, n) + 1) && (get(_s, n) <= 101)
    {
            n := n + 1
            sum := sum + 1
    }

}

method test2() returns (sum: Int)
    ensures forall _s: State :: <_s> ==> get(_s, sum) == 102
{

   var n: Int
   n := 0
   sum := 1

   while (n <= 100)
   invariant forall _s: State :: <_s> ==> get(_s, n) == $n && get(_s, sum) == $n + 1 && $n <= 101
   {
           n := n + 1
           sum := sum + 1
   }
}

method test3(n: Int) returns (res: Int)
    requires forall _s1: State, _s2:State :: <_s1> && <_s2> ==> get(_s1, n) == get(_s2, n)
    ensures forall _s1: State, _s2:State :: <_s1> && <_s2> ==> get(_s1, res) == get(_s2, res)
{
    assume n == 11 && res == 0

    var i: Int
    i := n

    while (i > 10)
    invariant forall _s: State :: <_s> ==> get(_s, i) >= 10 && get(_s, res) == get(_s, n) - get(_s, i)
    invariant forall _s: State :: <_s> ==> get(_s, n) == 11
    {
        i := i - 1
        res := res + 1
    }
}

method divisible(x: Int, y: Int, i: Int) returns (res: Int)
requires forall _s: State :: <_s> ==> get(_s, x) >= get(_s, y) && get(_s, y) > 0 && get(_s, x) % get(_s, y) == 0
ensures forall _s: State :: <_s> ==> get(_s, res) == 1
{
    var remain_x: Int
    remain_x := x

    var ind: Int
    ind := 0

    // frame forall _s: State :: <_s> ==> get(_s, x) >= get(_s, y) && get(_s, y) > 0 && get(_s, x) % get(_s, y) == 0 {
        while (ind < x / y)
        invariant forall _s: State :: <_s> ==> get(_s, remain_x) == get(_s, x) - get(_s, ind) * get(_s, y) && get(_s, x) >= get(_s, y) && get(_s, y) > 0 &&  get(_s, ind) <= get(_s, x) / get(_s, y)
        {
            remain_x := remain_x - y
            ind := ind + 1
        }
    // }

    if (remain_x == 0) {
        res := 1
    } else {
        res := 0
    }
}





method test() returns (sum: Int)
    ensures forall <_s> :: _s[sum] == 102
{

    var n: Int
    n := 0
    sum := 1

    while (n <= 100)
    invariant forall <_s> :: (_s[sum] == _s[n] + 1) && (_s[n] <= 101)
    {
            n := n + 1
            sum := sum + 1
    }

}

method test2() returns (sum: Int)
    ensures forall <_s> :: _s[sum] == 102
{

   var n: Int
   n := 0
   sum := 1

   while (n <= 100)
   invariant forall <_s> :: _s[n] == $n && _s[sum] == $n + 1 && $n <= 101
   {
           n := n + 1
           sum := sum + 1
   }
}

method test3(n: Int) returns (res: Int)
    requires forall _s1: State, _s2:State :: <_s1> && <_s2> ==> _s1[n] == _s2[n]
    ensures forall _s1: State, _s2:State :: <_s1> && <_s2> ==> _s1[res] == _s2[res]
{
    assume n == 11 && res == 0

    var i: Int
    i := n

    while (i > 10)
    invariant forall <_s> :: _s[i] >= 10 && _s[res] == _s[n] - _s[i]
    invariant forall <_s> :: _s[n] == 11
    {
        i := i - 1
        res := res + 1
    }
}

method divisible(x: Int, y: Int, i: Int) returns (res: Int)
requires forall <_s> :: _s[x] >= _s[y] && _s[y] > 0 && _s[x] % _s[y] == 0
ensures forall <_s> :: _s[res] == 1
{
    var remain_x: Int
    remain_x := x

    var ind: Int
    ind := 0

    // frame forall <_s> :: _s[x] >= _s[y] && _s[y] > 0 && _s[x] % _s[y] == 0 {
        while (ind < x / y)
        invariant forall <_s> :: _s[remain_x] == _s[x] - _s[ind] * _s[y] && _s[x] >= _s[y] && _s[y] > 0 &&  _s[ind] <= _s[x] / _s[y]
        {
            remain_x := remain_x - y
            ind := ind + 1
        }
    // }

    if (remain_x == 0) {
        res := 1
    } else {
        res := 0
    }
}





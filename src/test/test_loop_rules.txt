// WhileSync
/*
method test_forall(x: Int) returns (y: Int)
requires forall _s: State :: <_s> ==> get(_s, x) > 0
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, x)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, y) == get(_s2, y)
{
    y := 0
    while syncRule (y < x)
    invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, x) && get(_s1, y) == get(_s2, y)
    decreases x - y
    {
        y := y + 1
    }
}

method test_exists(x: Int) returns (y: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, x) && get(_s1, x) > 0
requires exists _s1: State, _s2: State :: <_s1> && <_s2>
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, y) == get(_s2, y)
{
    y := 0
    while syncTotRule (y < x)
    invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, x) && get(_s1, y) == get(_s2, y)
    invariant exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, x) == get(_s2, x) && get(_s1, y) == get(_s2, y)
    decreases x - y
    {
        y := y + 1
    }
}


// WhileSyncTot
method test_forall1(x: Int) returns (y: Int)
requires forall _s: State :: <_s> ==> get(_s, x) > 0
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, x)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, y) == get(_s2, y)
{
    y := 0
    while syncRule (y < x)
    invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x) == get(_s2, x) && get(_s1, y) == get(_s2, y)
    decreases x - y
    {
        y := y + 1
    }
}

// ForAllExists
method test_forall1(x: Int, t: Int) returns (y: Int)
requires forall <_s>: State :: get(_s, x) > 0
requires forall <_s1>: State, <_s2>: State :: (get(_s1, t) == 1 && get(_s2, t) == 2) ==> (get(_s1, x) == get(_s2, x))
ensures forall <_s1>: State, <_s2>: State :: (get(_s1, t) == 1 && get(_s2, t) == 2) ==> (get(_s1, y) == get(_s2, y))
{
    y := 0
    while forAllExistsRule (y < x)
    invariant forall <_s1>: State, <_s2>: State :: (get(_s1, t) == 1 && get(_s2, t) == 2) ==> (get(_s1, x) == get(_s2, x) && get(_s1, y) == get(_s2, y))
    decreases x - y
    {
       y := y + 1
    }
}
*/

method test_forall2(h: Int) returns (l: Int)
ensures forall <_s1>: State, <_s2>: State :: (exists <_s3>: State :: get(_s1, h) == get(_s3, h) && get(_s2, l) == get(_s3, l))
{
    var i: Int
    i := 0
    l := 0

    while (i < 100)
    invariant forall <_s1>: State, <_s2>: State :: (exists <_s3>: State :: get(_s1, i) == get(_s2, i) && get(_s3, i) == get(_s1, i) && get(_s1, h) == get(_s3, h) && get(_s2, l) == get(_s3, l))
    decreases 100 - i
    {
        l := l + h - h
        i := i + 1
    }
}

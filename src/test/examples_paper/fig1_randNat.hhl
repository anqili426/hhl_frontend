method randNat() returns (y:Int)
    requires exists <_s> :: true
	ensures forall <_s> :: 1 <= _s[y] && _s[y] <= 2
	ensures exists <_s> :: _s[y] == 1
	ensures exists <_s> :: _s[y] == 2
{
	var x: Int
	havoc x {hint}
	use hint(0)
	use hint(1)
	if (x > 0) {
		y := 1
	}
	else {
		y := 2
	}
}

method buggy() returns (x: Int)
	requires exists <_s> :: true
	ensures exists <<_s>> :: _s[x] == 2
	ensures exists <<_s>> :: _s[x] == 4
{
	x := randNat()
	x := x + x
	assert x % 2 == 1
}

method almostCorrect(x: Int) returns (o: Int)
	requires forall <_s> :: _s[x] >= 0
	ensures forall <<_s>> :: _s[x] == 0 && _s[o] == 0
{
	havoc o
	assume o >= 0
	var y: Int
	y := x + o
	assert y > 0
}

method equi_error(h: Int, l: Int, t: Int)
	requires exists <_s1>, <_s2> :: _s1[t] == 1 && _s2[t] == 2
	requires forall <_s1>, <_s2> :: _s1[l] == _s2[l]
	ensures (exists <<_s1>> :: _s1[t] == 1) ==> (exists <<_s2>> :: _s2[t] == 2)
	ensures (exists <<_s1>> :: _s1[t] == 2) ==> (exists <<_s2>> :: _s2[t] == 1)
{
	if (h > 0) {
		assert l >= 0
	}
	if (l < 0) {
		assert false
	}
}

method minimum(n: Int) returns (x: Int, y: Int)
requires exists <_s> :: true
requires forall <_s1>, <_s2> :: _s1[n] == _s2[n]
ensures exists <_s> :: (forall <_s1> :: _s[x] <= _s1[x] && _s[y] <= _s1[y])
{
    var i: Int
    var r: Int
    i := 0
    x := 0
    y := 0
    while (i < n)
    invariant exists <_s> :: (forall <_s1> :: _s[x] <= _s1[x] && _s[y] <= _s1[y])
    invariant forall <_s1>, <_s2> :: _s1[n] == _s2[n] && _s1[i] == _s2[i]
    decreases n - i
    {
        havoc i {hint}
        assume r >= 5
        use hint(5)
        x := x + y + 2 * i + 3 * r
        y := x + 3 * i + 2 * r
        if (x >= n) {
            y := y + r
        }
        i := i + 1
    }
}
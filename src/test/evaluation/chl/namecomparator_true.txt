method compare1(name1: Int, name2: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==> get(_s1, name1) == get(_s2, name2) && get(_s1, name2) == get(_s2, name1) 
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==> ((get(_s1, res) > 0 && get(_s2, res) < 0) || (get(_s1, res) < 0 && get(_s2, res) > 0) || (get(_s1, res) == 0 && get(_s2, res) == 0)) {
    if (name1 == name2) {
        res := 0
    } else {
        var ind: Int
        ind := 0
        var currName: Int

        var ret: Int
        ret := 0

        while (ind < 3 && ret == 0) {
            currName := nonDet(ind) // Need to update parser etc to support this!
            if (currName == name1) {
                res := 1
                ret := 1    // Force loop exit & return
            } else {
                if (currName == name2) {
                    res := -1
                    ret := 1    // Force loop exit & return
                } 
            }
            i := i + 1
        }
    }

    if (ret == 0) {
        if (name1 > name2) {
            res := 1
        } else {
            if (name1 == name2) {
                res := 0
            } else {
                res := -1
            }
        }
    }
    
}
// Model != null as positive value, == null as non-positive value
// P1
method compare1(intVal1: Int, fileName1: Int, intVal2: Int, fileName2: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==> get(_s1, intVal1) == get(_s2, intVal2) && get(_s1, fileName1) == get(_s2, fileName2) && get(_s1, intVal2) == get(_s2, intVal1) && get(_s1, fileName2) == get(_s2, fileName1)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==> ((get(_s1, res) > 0 && get(_s2, res) < 0) || (get(_s1, res) < 0 && get(_s2, res) > 0) || (get(_s1, res) == 0 && get(_s2, res) == 0))
{
    res := 0
    if (intVal1 <= 0) {
        if (intVal2 <= 0) {
            res := 0
        } else {
            res := 1
        }
    } else {
        if (intVal2 <= 0) {
            res := -1
        } else {
            if (fileName1 <= 0) {
                if (fileName2 <= 0) {
                    res := 0
                } else {
                    res := 1
                }
            } else {
                if (fileName2 <= 0) {
                    res := -1
                } else {
                    res := fileName1 - fileName2
                }
            }
        }
    }
}

// P2
method compare2(intVal1: Int, fileName1: Int, intVal2: Int, fileName2: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, intVal1) == get(_s3, intVal1) && get(_s1, fileName1) == get(_s3, fileName1) && get(_s2, intVal2) == get(_s3, intVal2) && get(_s2, fileName2) == get(_s3, fileName2) && get(_s1, intVal2) == get(_s2, intVal1) && get(_s1, fileName2) == get(_s2, fileName1)
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> (get(_s1, res) > 0 && get(_s2, res) > 0 ==> get(_s3, res) > 0)
{
    res := 0
    if (intVal1 <= 0) {
        if (intVal2 <= 0) {
            res := 0
        } else {
            res := 1
        }
    } else {
        if (intVal2 <= 0) {
            res := -1
        } else {
            if (fileName1 <= 0) {
                if (fileName2 <= 0) {
                    res := 0
                } else {
                    res := 1
                }
            } else {
                if (fileName2 <= 0) {
                    res := -1
                } else {
                    res := fileName1 - fileName2
                }
            }
        }
    }
}

// P3
method compare3(intVal1: Int, fileName1: Int, intVal2: Int, fileName2: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> get(_s1, intVal1) == get(_s3, intVal1) && get(_s1, fileName1) == get(_s3, fileName1) && get(_s2, intVal2) == get(_s3, intVal2) && get(_s2, fileName2) == get(_s3, fileName2) && get(_s1, intVal2) == get(_s2, intVal1) && get(_s1, fileName2) == get(_s2, fileName1)
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==> (get(_s1, res) == 0 ==> ((get(_s2, res) > 0 && get(_s3, res) > 0) || (get(_s2, res) < 0 && get(_s3, res) < 0) || (get(_s2, res) == 0 && get(_s3, res) == 0)))
{
    res := 0
    if (intVal1 <= 0) {
        if (intVal2 <= 0) {
            res := 0
        } else {
            res := 1
        }
    } else {
        if (intVal2 <= 0) {
            res := -1
        } else {
            if (fileName1 <= 0) {
                if (fileName2 <= 0) {
                    res := 0
                } else {
                    res := 1
                }
            } else {
                if (fileName2 <= 0) {
                    res := -1
                } else {
                    res := fileName1 - fileName2
                }
            }
        }
    }
}
method test() returns (sum: Int) 
requires exists _s: State :: <_s>
ensures exists _s: State :: <_s> && get(_s, sum) == 0
{
    sum := 0
    var i: Int
    var j: Int 
    var p: Int 
    var n: Int
    i := 0
    j := 0
    p := 0

    while (i < 10) 
    {hint1} invariant $n <= 10 ==> exists _s: State :: <_s> && 
                                    ((get(_s, i) <= 5) ==> ((get(_s, j) == 0) && (get(_s, p) == 0))) &&
                                    ((get(_s, i) > 5) ==> ((get(_s, j) == 1) && (get(_s, p) == 1))) &&        
                                    get(_s, sum) == 0 &&
                                    get(_s, i) == $n
    {
       var increment: Int

        // g(j, p)
        /*hyperAssume forall _s: State :: <_s> ==> 
                    ((get(_s, j) == 0 ==> get(_s, increment) == get(_s, p)) &&
                    (get(_s, j) == 1 ==> get(_s, increment) == get(_s, p) - 1) &&
                    ((get(_s, j) < 0 || get(_s, j) > 1) ==> get(_s, increment) == 1))
        */
        if (j == 0) {
            increment := p
        } 

        if (j == 1) {
            increment := p - 1
        }

        if (j < 0 || j > 1) {
            increment := 1
        }

        sum := sum + increment

        if (i == 5) {
            j := 1
        }

        // flipCoin()
        havoc p {hint2}
        assume p == 0 || p == 1

        i := i + 1

        // Given the following hints, why does the program verify? 
        // use forall _s: State :: <_s> && get(_s, i) <= 7 ==> hint2(0)
        // use forall _s: State :: <_s> && get(_s, i) > 7 ==> hint2(1)

        use hint2(0)
        use hint2(1)
    }
    use hint1(10)
}
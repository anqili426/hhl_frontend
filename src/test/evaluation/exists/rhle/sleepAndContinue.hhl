method test() returns (success: Int)
requires exists _s1: State, _s2: State :: <_s1> && <_s2>
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && _s1[success] != _s2[success]
{
    var currTime: Int
    var lastTime: Int
    var currTotal: Int

    // getCurrentTimeMs
    havoc currTime {hint1}
    assume currTime > 0
    use hint1(1)
    use hint1(2)

    lastTime := -1
    currTotal := 0

    // recordTimeStamp
    if (lastTime >= 0) {
        var elapsedTime: Int
        elapsedTime := currTime - lastTime
        currTotal := currTotal + elapsedTime
    }
    lastTime := currTime

    // sleep
    var sleepTime: Int
    havoc sleepTime {hint2}
    assume sleepTime >= 80 && sleepTime <= 120
    use hint2(100)
    use hint2(101)

    var old_currTime: Int
    old_currTime := currTime
    havoc currTime {hint5}
    use hint5(101)
    use hint5(103)
    // If the following hint is used instead, verification doesn't terminate
    // use forall _s: State :: <_s> ==> hint5(_s[old_currTime] + _s[sleepTime])
    assume currTime == old_currTime + sleepTime

    var counter : Int
    counter := 0

    while (counter < 5)
    {hint4} invariant $n <= 5 ==> exists _s1: State, _s2: State :: <_s1> && <_s2> && 
                                _s1[counter] == $n && _s2[counter] == $n &&
                                _s1[currTime] - _s1[lastTime] == 100 &&
                                _s2[currTime] - _s2[lastTime] == 101 &&
                                _s1[currTotal] == 100 * _s1[counter] &&
                                _s2[currTotal] == 101 * _s2[counter] &&
                                _s1[lastTime] >= 0 && _s2[lastTime] >= 0
    {
        // recordTimeStamp
        if (lastTime >= 0) {
            var elapsedTime1: Int
            elapsedTime1 := currTime - lastTime
            currTotal := currTotal + elapsedTime1
        }
        lastTime := currTime

        // sleep
        havoc sleepTime {hint3}
        assume sleepTime >= 80 && sleepTime <= 120
        use hint3(100)
        use hint3(101)

        old_currTime := currTime

        havoc currTime {hint6}
        use forall _s: State :: <_s> ==> hint6(_s[old_currTime] + _s[sleepTime])
        assume currTime == old_currTime + sleepTime

        counter := counter + 1
    }

    if (currTotal == 500) {
        success := 1
    } else {
        success := 0
    }
    use hint4(5)
}
// Cannot encode the loops here, because the loop condition is true
// The two sets of states after the loops will be empty
// The postcondition will be trivially true
// Not sure about translation
method refine() returns (c: Int, x: Int)
ensures forall _s1: State :: <_s1> && get(_s1, c) == 0 ==>
    (exists _s2: State :: <_s2> && get(_s2, c) == 1 && get(_s1, x) == get(_s2, x))
{
    var r: Int
    var iter: Int
    var incr: Int

    havoc r {hint0}
    assume 0 <= r && r <= 1
    use hint0(0)
    use hint0(1)

    if (r == 0) {
        x := 0
        c := 0
        havoc iter {hint1}
        x := x + iter
    } else {
        x := 0
        c := 1
        havoc incr {hint2}
        x := x + incr
    }

    use forall _s: State :: <_s> ==> hint2(get(_s, iter))
}
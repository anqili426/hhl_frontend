method p1_gni1() returns (h: Int, o: Int)
{
    o := 1
    while (true)
    invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==> 
            (exists _s3: State :: <_s3> && _s3[h] == _s2[h] && _s3[o] == _s1[o])
    {
        havoc h {hint1}
        if (h > 0) {
            o := -1 * o
        } else {
            o := -1 * o + (h - h)
        }
        o := -1
        use forall _s1: State, _s2: State :: <_s1> && <_s2> ==> hint1(_s2[h])
    }
}
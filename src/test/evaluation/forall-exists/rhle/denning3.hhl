 /* method denning3(e_in: Int, i_in: Int, f_in: Int, x_in: Int, sum_in: Int)
returns (e_out: Int, i_out: Int, f_out: Int, x_out: Int, sum_out: Int, res: Int)
requires forall _s1: State :: <_s1> ==>
    (exists _s2: State :: <_s2> && _s1[e_in] == _s2[e_in] && _s1[i_in] == _s2[i_in] && _s1[x_in] != _s2[x_in])
ensures forall _s1: State :: <_s1> ==>
    (exists _s2: State :: <_s2> && _s1[e_out] == _s2[e_out] && _s1[i_out] == _s2[i_out] && _s1[x_out] != _s2[x_out])
{
    var max_sum: Int
    var err: Int
    max_sum := 100
    err := 0

    sum_out := 0
    i_out := 0
    e_out := 1
    f_out := f_in
    x_out := x_in

    assume x_out > 0

    while (e_out == 1 && err == 0)
    {hint1} invariant forall _s1: State :: <_s1> ==>
                          (_s1[e_out] == 1) &&
                          (_s1[x_out] > 0) &&
                          (_s1[err] == 0 || _s1[err] == 1) &&
                          (_s1[sum_out] == _s1[x_out] * _s1[i_out]) &&
                          (_s1[i_out] == $n) &&
                          (_s1[err] == 0 ==> _s1[sum_out] <= _s1[max_sum]) &&
                          (_s1[err] == 1 ==> _s1[sum_out] > _s1[max_sum]) &&
                          ((_s1[sum_out] > _s1[max_sum]) ==> _s1[err] == 1)
    {hint2} invariant forall _s1: State :: (<_s1> && _s1[err] == 1) ==>
                                $n == ((_s1[max_sum] / _s1[x_out]) + 1)
    {
        sum_out := sum_out + x_out
        i_out := i_out + 1
        f_out := i_out
        if (sum_out > max_sum) {
            err := 1
        }
    }

    // use forall _s: State :: <_s> ==> hint1(_s[max_sum] / _s[x_out]) && hint2(_s[max_sum] / _s[x_out])
    if (err == 1) {
        res := 0
    } else {
        res := 1
    }
} */

method simplified(i_in: Int, x_in: Int)
returns (i_out: Int, sum_out: Int)
requires forall _s: State :: <_s> ==> _s[x_in] > 0
requires exists _s1: State, _s2: State :: <_s1> && <_s2>  && _s1[x_in] == 5 && _s2[x_in] == 20
// ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && _s1[i_out] == 21 && _s2[i_out] == 6
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && (forall _s3: State :: <_s3> && _s3[x_in] == _s1[x_in] ==> _s3[i_out] > _s2[i_out])
{
        var err: Int
        err := 0

        let $s1: State :: <$s1> && $s1[x_in] == 5
        let $s2: State :: <$s2> && $s2[x_in] == 20

        i_out := 0
        sum_out := 0

        while (err == 0)
        {hint2} invariant ($n - 1) * $s1[x_in] <= 100 && $s1[x_in] > 0 ==>
            exists _s: State :: <_s> &&
            _s[x_in] == $s1[x_in] &&
            _s[x_in] > 0 &&
            _s[sum_out] == _s[i_out] * _s[x_in] &&
            (_s[sum_out] > 100 ==> _s[err] == 1) &&
            (_s[sum_out] <= 100 ==> _s[err] == 0) &&
            (_s[i_out] == $n)
        {hint3} invariant ($n - 1) * $s2[x_in] <= 100 && $s2[x_in] > 0 ==>
                    exists _s: State :: <_s> &&
                    _s[x_in] == $s2[x_in] &&
                    _s[x_in] > 0 &&
                    _s[sum_out] == _s[i_out] * _s[x_in] &&
                    (_s[sum_out] > 100 ==> _s[err] == 1) &&
                    (_s[sum_out] <= 100 ==> _s[err] == 0) &&
                    (_s[i_out] == $n)
        invariant forall _s: State :: <_s> ==> (_s[i_out] == $n &&
                     (_s[err] == 0 || _s[err] == 1) &&
                     _s[sum_out] == _s[x_in] * _s[i_out] &&
                     _s[x_in] > 0 &&
                     (_s[err] == 1 ==> (($n - 1) == 100 / _s[x_in] && _s[sum_out] > 100)) &&
                     (_s[err] == 0 ==> _s[sum_out] <= 100 && ($n - 1) * _s[x_in] < 100))
        {
            sum_out := sum_out + x_in
            i_out := i_out + 1
            if (sum_out > 100) {
                err := 1
            }
        }

        use hint2(21)
        use hint3(6)
}

/*
method simplified(i_in: Int, x_in: Int)
returns (i_out: Int, sum_out: Int)
requires forall _s: State :: <_s> ==> _s[x_in] > 0
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> _s1[x_in] == _s2[x_in]
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> _s1[i_out] == _s2[i_out]
{
        var err: Int
        err := 0

        i_out := 0
        sum_out := 0

        while (err == 0)
        invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==>
            _s1[i_out] == _s2[i_out]
        invariant forall _s: State :: <_s> ==> (_s[i_out] == $n &&
            (_s[err] == 0 || _s[err] == 1) &&
            _s[sum_out] == _s[x_in] * _s[i_out] &&
            _s[x_in] > 0 &&
            (_s[err] == 1 ==> (($n - 1) == 100 / _s[x_in] && _s[sum_out] > 100)) &&
            (_s[err] == 0 ==> _s[sum_out] <= 100 && ($n - 1) * _s[x_in] < 100))
        {
            sum_out := sum_out + x_in
            i_out := i_out + 1
            if (sum_out > 100) {
                err := 1
            }
        }
}*/
method unused(p1: Int, p2: Int, i: Int) returns (res: Int)
requires forall <_s1a>, <_s2a> :: _s1a[i] == 1 && _s2a[i] == 2 ==>
                    (exists <_s1b>, <_s2b> :: _s1b[i] == 3 && _s2b[i] == 4 &&
                                              _s1a[p1] == _s1b[p1] &&
                                              _s1a[p2] != _s1b[p2] &&
                                              _s2a[p1] != _s2b[p1] &&
                                              _s2a[p2] == _s2b[p2])
ensures forall <_s1a>, <_s2a> :: _s1a[i] == 1 && _s2a[i] == 2 ==>
             (exists <_s1b>, <_s2b> :: _s1b[i] == 3 && _s2b[i] == 4 && (_s1a[res] == _s1b[res] || _s2a[res] == _s2b[res]))
{
    hyperAssert forall <_s1a>, <_s2a> :: _s1a[i] == 1 && _s2a[i] == 2 ==>
                                    (exists <_s1b>, <_s2b> :: _s1b[i] == 3 && _s2b[i] == 4 &&
                                                              _s1a[p1] == _s1b[p1] &&
                                                              _s1a[p2] != _s1b[p2] &&
                                                              _s2a[p1] != _s2b[p1] &&
                                                              _s2a[p2] == _s2b[p2])
    var coin: Int
    havoc coin {hint}
    assume coin == 0 || coin == 1
    use hint(0)
    use hint(1)
    res := coin
}
method calc_salary(sal1: Int, sal2: Int, sal3: Int, i: Int) returns (avg: Int)
requires forall <_s1>, <_s2> :: (_s1[i] == 1 && _s2[i] == 2) ==>
            (exists <_s3> :: _s3[i] == 3 &&
                     _s1[sal1] == _s3[sal1] &&
                     _s1[sal2] == _s3[sal2] &&
                     _s1[sal3] == _s3[sal3] &&
                     (_s1[sal1] + _s1[sal2] + _s1[sal3]) == (_s2[sal1] + _s2[sal2] + _s2[sal3]) &&
                     (_s3[sal1] + _s3[sal2] + _s3[sal3]) == (_s2[sal1] + _s2[sal2] + _s2[sal3])
             )
ensures forall <_s1>, <_s2> :: (_s1[i] == 1 && _s2[i] == 2) ==>
    (exists <_s3> :: (_s3[i] == 3 && _s2[avg] == _s3[avg]))
{
    // If we use this version, we can't prove the postcondition because of triggers
    // I don't understand why the issue only occurs in this test case. The solution is to change all exists-encodings from in_set_exists to in_set_exists_limited
    var sum: Int
    sum := 0
    sum := sum + sal1
    sum := sum + sal2
    sum := sum + sal3
    avg := sum / 3

    // avg := (sal1 + sal2 + sal3) / 3
}
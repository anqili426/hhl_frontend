 /* method denning3(e_in: Int, i_in: Int, f_in: Int, x_in: Int, sum_in: Int)
returns (e_out: Int, i_out: Int, f_out: Int, x_out: Int, sum_out: Int, res: Int)
requires forall _s1: State :: <_s1> ==>
    (exists _s2: State :: <_s2> && get(_s1, e_in) == get(_s2, e_in) && get(_s1, i_in) == get(_s2, i_in) && get(_s1, x_in) != get(_s2, x_in))
ensures forall _s1: State :: <_s1> ==>
    (exists _s2: State :: <_s2> && get(_s1, e_out) == get(_s2, e_out) && get(_s1, i_out) == get(_s2, i_out) && get(_s1, x_out) != get(_s2, x_out))
{
    var max_sum: Int
    var err: Int
    max_sum := 100
    err := 0

    sum_out := 0
    i_out := 0
    e_out := 1
    f_out := f_in
    x_out := x_in

    assume x_out > 0

    while (e_out == 1 && err == 0)
    {hint1} invariant forall _s1: State :: <_s1> ==>
                          (get(_s1, e_out) == 1) &&
                          (get(_s1, x_out) > 0) &&
                          (get(_s1, err) == 0 || get(_s1, err) == 1) &&
                          (get(_s1, sum_out) == get(_s1, x_out) * get(_s1, i_out)) &&
                          (get(_s1, i_out) == $n) &&
                          (get(_s1, err) == 0 ==> get(_s1, sum_out) <= get(_s1, max_sum)) &&
                          (get(_s1, err) == 1 ==> get(_s1, sum_out) > get(_s1, max_sum)) &&
                          ((get(_s1, sum_out) > get(_s1, max_sum)) ==> get(_s1, err) == 1)
    {hint2} invariant forall _s1: State :: (<_s1> && get(_s1, err) == 1) ==>
                                $n == ((get(_s1, max_sum) / get(_s1, x_out)) + 1)
    {
        sum_out := sum_out + x_out
        i_out := i_out + 1
        f_out := i_out
        if (sum_out > max_sum) {
            err := 1
        }
    }

    // use forall _s: State :: <_s> ==> hint1(get(_s, max_sum) / get(_s, x_out)) && hint2(get(_s, max_sum) / get(_s, x_out))
    if (err == 1) {
        res := 0
    } else {
        res := 1
    }
} */

method simplified(i_in: Int, x_in: Int)
returns (i_out: Int, sum_out: Int)
requires forall _s: State :: <_s> ==> get(_s, x_in) > 0
requires exists _s1: State, _s2: State :: <_s1> && <_s2>  && get(_s1, x_in) == 5 && get(_s2, x_in) == 20
// ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i_out) == 21 && get(_s2, i_out) == 6
ensures exists _s1: State, _s2: State :: <_s1> && <_s2> && (forall _s3: State :: <_s3> && get(_s3, x_in) == get(_s1, x_in) ==> get(_s3, i_out) > get(_s2, i_out))
{
        var err: Int
        err := 0

        let $s1: State :: <$s1> && get($s1, x_in) == 5
        let $s2: State :: <$s2> && get($s2, x_in) == 20

        i_out := 0
        sum_out := 0

        while (err == 0)
        {hint2} invariant ($n - 1) * get($s1, x_in) <= 100 && get($s1, x_in) > 0 ==>
            exists _s: State :: <_s> &&
            get(_s, x_in) == get($s1, x_in) &&
            get(_s, x_in) > 0 &&
            get(_s, sum_out) == get(_s, i_out) * get(_s, x_in) &&
            (get(_s, sum_out) > 100 ==> get(_s, err) == 1) &&
            (get(_s, sum_out) <= 100 ==> get(_s, err) == 0) &&
            (get(_s, i_out) == $n)
        {hint3} invariant ($n - 1) * get($s2, x_in) <= 100 && get($s2, x_in) > 0 ==>
                    exists _s: State :: <_s> &&
                    get(_s, x_in) == get($s2, x_in) &&
                    get(_s, x_in) > 0 &&
                    get(_s, sum_out) == get(_s, i_out) * get(_s, x_in) &&
                    (get(_s, sum_out) > 100 ==> get(_s, err) == 1) &&
                    (get(_s, sum_out) <= 100 ==> get(_s, err) == 0) &&
                    (get(_s, i_out) == $n)
        invariant forall _s: State :: <_s> ==> (get(_s, i_out) == $n &&
                     (get(_s, err) == 0 || get(_s, err) == 1) &&
                     get(_s, sum_out) == get(_s, x_in) * get(_s, i_out) &&
                     get(_s, x_in) > 0 &&
                     (get(_s, err) == 1 ==> (($n - 1) == 100 / get(_s, x_in) && get(_s, sum_out) > 100)) &&
                     (get(_s, err) == 0 ==> get(_s, sum_out) <= 100 && ($n - 1) * get(_s, x_in) < 100))
        {
            sum_out := sum_out + x_in
            i_out := i_out + 1
            if (sum_out > 100) {
                err := 1
            }
        }

        use hint2(21)
        use hint3(6)
}

/*
method simplified(i_in: Int, x_in: Int)
returns (i_out: Int, sum_out: Int)
requires forall _s: State :: <_s> ==> get(_s, x_in) > 0
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, x_in) == get(_s2, x_in)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, i_out) == get(_s2, i_out)
{
        var err: Int
        err := 0

        i_out := 0
        sum_out := 0

        while (err == 0)
        invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==>
            get(_s1, i_out) == get(_s2, i_out)
        invariant forall _s: State :: <_s> ==> (get(_s, i_out) == $n &&
            (get(_s, err) == 0 || get(_s, err) == 1) &&
            get(_s, sum_out) == get(_s, x_in) * get(_s, i_out) &&
            get(_s, x_in) > 0 &&
            (get(_s, err) == 1 ==> (($n - 1) == 100 / get(_s, x_in) && get(_s, sum_out) > 100)) &&
            (get(_s, err) == 0 ==> get(_s, sum_out) <= 100 && ($n - 1) * get(_s, x_in) < 100))
        {
            sum_out := sum_out + x_in
            i_out := i_out + 1
            if (sum_out > 100) {
                err := 1
            }
        }
}*/
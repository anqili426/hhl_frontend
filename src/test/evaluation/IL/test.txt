/*
method testLoop(x: Int, i: Int) returns (y: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==> get(_s1, x) <= get(_s2, x)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==> get(_s1, y) <= get(_s2, y)
{
        y := 0
        while forAllExistsRule (y < x)
        invariant forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==>
                get(_s1, y) <= get(_s2, y) &&
                (get(_s1, x) - get(_s1, y)) <= (get(_s2, x) - get(_s2, y))
        {
            y := y + 1
        }
}

method fib_mono(n: Int, t: Int) returns (a: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, t) == 1 && get(_s2, t) == 2 ==> get(_s1, n) >= get(_s2, n)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, t) == 1 && get(_s2, t) == 2 ==> get(_s1, a) >= get(_s2, a)
{
    var b: Int
    var i: Int

    a := 0
    b := 1
    i := 0

    while forAllExistsRule (i < n)
    invariant forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, t) == 1 && get(_s2, t) == 2 ==>
                    ((get(_s1, n) - get(_s1, i)) >= (get(_s2, n) - get(_s2, i))) &&
                    (get(_s1, a) >= get(_s2, a)) &&
                    (get(_s1, b) >= get(_s2, b))
    invariant forall _s: State :: <_s> ==> (get(_s, b) >= get(_s, a)) && (get(_s, a) >= 0)
    {
        var tmp: Int
        tmp := b
        b := a + b
        a := tmp
        i := i + 1
    }
}


method test(h: Int) returns (l: Int)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> (exists _s3: State :: <_s3> && get(_s1, h) == get(_s3, h) && get(_s2, l) == get(_s3, l))
{
    var i: Int
    i := 0
    l := 0

    var t: Int

    while forAllExistsRule (i < 100)
    invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==> (exists _s3: State :: <_s3> && get(_s1, i) == get(_s2, i) && get(_s3, i) == get(_s1, i) && get(_s1, h) == get(_s3, h) && get(_s2, l) == get(_s3, l))
    decreases t
    {
        l := l + h - h
        i := i + 1
    }
} */

method test1(a: Int) returns (b: Int)

{
    while (true) {

    }
}

method inc_good(x_in: Int, m: Int) returns (x_out: Int)
requires forall <_s> :: _s[x_in] == _s[m] && _s[m] >= 0
ensures forall <_s> :: _s[x_out] == _s[m] + 1 && _s[m] >= 0
ensures forall <<_s>> :: false
{
    assert x_in >= 0
    x_out := x_in + 1
}

method client_good(x_in: Int, m: Int) returns (x_out: Int)
requires forall <_s> :: (_s[x_in] == _s[m] && _s[m] >= 0)
ensures forall <_s> :: (_s[x_out] == _s[m] + 2 && _s[m] >= 0)
ensures forall <<_s>> :: false
{
    x_out := inc_good(x_in, m)
    var new_m: Int
    new_m := m + 1
    var new_x_out : Int
    new_x_out := inc_good(x_out, new_m)
    x_out := new_x_out
}

method test_good()
ensures forall <<_s>> :: false
{
    var x_in: Int
    x_in := 0

    var m: Int
    m := x_in

    var x_out: Int
    x_out := client_good(x_in, m)
    assert x_out >= 2
}


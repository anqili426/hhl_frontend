// This test case is incomplete -- need to determine loop invariants
method compare1(name1: Int, name2: Int) returns (res: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, name1) == get(_s2, name2) && get(_s1, name2) == get(_s2, name1)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, res) == -1 * get(_s2, res)
{
    if (name1 == name2) {
        res := 0
    } else {
        var ind: Int
        ind := 0
        var currName: Int

        var ret: Int
        ret := 0

        while (ind < 3 && ret == 0)
        invariant forall _s: State :: <_s> ==> get(_s, ind) <= 3 && get(_s, ret) <= 1
        invariant forall _s: State :: <_s> ==> (((get(_s, ret) == 1) && (get(_s, res) == 1)) ==> (get(_s, name1) == get(_s, currName))) &&
                                               (((get(_s, ret) == 1) && (get(_s, res) == -1)) ==> (get(_s, name2) == get(_s, currName)))
                                               // (((get(_s, name1) != get(_s, currName) && (get(_s, name2) != get(_s, currName)))) ==> ((get(_s, ret) == 0) && (get(_s, res) == 0)))
        {
            havoc currName
            hyperAssume forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, currName) == get(_s2, currName)

            if (name1 == currName) {
                res := 1
                ret := 1    // Force loop exit & return
            } else {
                if (name2 == currName) {
                    res := -1
                    ret := 1    // Force loop exit & return
                }
            }
            ind := ind + 1
        }
    }

    if (ret == 0) {
        if (name1 > name2) {
            res := 1
        } else {
            if (name1 == name2) {
                res := 0
            } else {
                res := -1
            }
        }
    }
}

method compare2(name1: Int, name2: Int, i: Int) returns (res: Int)
requires forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==>
                                                        (get(_s1, name1) == get(_s3, name1)) && (get(_s1, name2) == get(_s2, name1)) && (get(_s2, name2) == get(_s3, name2))
ensures forall _s1: State, _s2: State, _s3: State :: <_s1> && <_s2> && <_s3> && get(_s1, i) == 1 && get(_s2, i) == 2 && get(_s3, i) == 3 ==>
        ((get(_s1, res) > 0 && get(_s2, res) > 0) ==> get(_s3, res) > 0)
{
    if (name1 == name2) {
        res := 0
    } else {
        var ind: Int
        ind := 0
        var currName: Int
        currName := 0

        var ret: Int
        ret := 0

        while (ind < 3 && ret == 0)
        invariant forall _s: State :: <_s> ==> get(_s, ind) <= 3 && get(_s, ret) <= 1 && get(_s, ret) >= 0
        invariant forall _s: State :: <_s> ==> ((get(_s, ret) == 1) ==> (get(_s, res) > 0 ==> (get(_s, name1) == get(_s, currName))
                                                                            && (get(_s, res) < 0 ==> (get(_s, name2) == get(_s, currName)))))
        invariant forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, currName) == get(_s2, currName)
        // invariant forall _s: State :: <_s> ==> get(_s, name1) != get(_s, name2)
        {
            havoc currName
            hyperAssume forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, currName) == get(_s2, currName)

            if (name1 == currName) {
                res := 1
                ret := 1    // Force loop exit & return
            } else {
                if (name2 == currName) {
                    res := -1
                    ret := 1    // Force loop exit & return
                }
            }
            ind := ind + 1
        }


    hyperAssert forall _s1: State, _s2: State :: <_s1> && <_s2> ==>
            get(_s1, currName) == get(_s2, currName)

    if (ret == 0) {
        if (name1 > name2) {
            res := 1
        } else {
            if (name1 == name2) {
                res := 0
            } else {
                res := -1
            }
        }
    }

   // hyperAssert forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2 ==>
        // get(_s1, currName) == get(_s2, currName)
    // hyperAssert forall _s1: State, _s2: State :: <_s1> && <_s2> && get(_s1, i) == 1 && get(_s2, i) == 2
           // && get(_s1, res) > 0 && get(_s2, res) > 0 ==> (get(_s1, name1) > get(_s1, name2)) && (get(_s2, name1) > get(_s2, name2))
    }
}

/*
method compare3(name1: Int, name2: Int) returns (res: Int)
requires forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, name1) == get(_s2, name2) && get(_s1, name2) == get(_s2, name1)
ensures forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, res) == -1 * get(_s2, res)
{
    if (name1 == name2) {
        res := 0
    } else {
        var ind: Int
        ind := 0
        var currName: Int

        var ret: Int
        ret := 0

        while (ind < 3 && ret == 0)
        invariant forall _s: State :: <_s> ==> get(_s, ind) <= 3 && get(_s, ret) <= 1
        invariant forall _s: State :: <_s> ==> (((get(_s, ret) == 1) && (get(_s, res) == 1)) ==> (get(_s, name1) == get(_s, currName))) &&
                                               (((get(_s, ret) == 1) && (get(_s, res) == -1)) ==> (get(_s, name2) == get(_s, currName)))
                                               // (((get(_s, name1) != get(_s, currName) && (get(_s, name2) != get(_s, currName)))) ==> ((get(_s, ret) == 0) && (get(_s, res) == 0)))
        {
            havoc currName
            hyperAssume forall _s1: State, _s2: State :: <_s1> && <_s2> ==> get(_s1, currName) == get(_s2, currName)

            if (name1 == currName) {
                res := 1
                ret := 1    // Force loop exit & return
            } else {
                if (name2 == currName) {
                    res := -1
                    ret := 1    // Force loop exit & return
                }
            }
            ind := ind + 1
        }
    }

    if (ret == 0) {
        if (name1 > name2) {
            res := 1
        } else {
            if (name1 == name2) {
                res := 0
            } else {
                res := -1
            }
        }
    }
}
*/
/*
    A test case for errors caused by a loops invariant which may not be preserved.
    Output:
        [WhileLoop, syncTotRule selected, 1 quantifier(s) removed] The following invariant might not hold:
        (true) && (exists <_s2: State> :: ((<_s2>) && (exists <_s3: State> :: ((<_s3>) && (forall <_s4: State> :: ((!(<_s4>)) || ((_s4[i]) < (9))))))))

        [WhileLoop, ExistsRule selected] The following invariant might not hold:
        exists <_s1: State> :: ((<_s1>) && (exists <_s2: State> :: ((<_s2>) && (exists <_s3: State> :: ((<_s3>) && (forall <_s4: State> :: ((!(<_s4>)) || ((_s4[i]) < (9)))))))))

        [WhileLoop, existsRule selected] The following loop invariant might not hold at entry point:
        exists <_s1: State> :: ((<_s1>) && (exists <_s2: State> :: ((<_s2>) && (exists <_s3: State> :: ((<_s3>) && (forall <_s4: State> :: ((<_s4>) ==> ((_s4[i]) < (9)))))))))
*/

method loopInvariantErr(t: Int) returns (out: Int)
    requires forall <_s> :: _s[t] >= 0 && _s[t] < 7
    requires forall <_s4>, <_s5> :: _s4[t] == _s5[t]
    ensures forall <_s4>, <_s5> :: _s4[out] == _s5[out]
{
    var i: Int
    i := t

    while existsRule (i < 10)
        invariant exists <_s1> :: exists <_s2> :: exists <_s3> :: forall <_s4> :: _s4[i] < 9
        decreases 10 - i
    {
        havoc out {hint1}
        assume out >= 1 && out <= 10
        use hint1(1)
        use hint1(2)

        i := i + 1
    }
}

